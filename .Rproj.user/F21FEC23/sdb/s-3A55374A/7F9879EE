{
    "collab_server" : "",
    "contents" : "library(leaflet)\nlibrary(RColorBrewer)\nlibrary(scales)\nlibrary(lattice)\nlibrary(dplyr)\n\n# Leaflet bindings are a bit slow; for now we'll just sample to compensate\nset.seed(100)\nzipdata <- allzips[sample.int(nrow(allzips), 10000),]\nsensordata <- allsensors\n# By ordering by centile, we ensure that the (comparatively rare) SuperZIPs\n# will be drawn last and thus be easier to see\nzipdata <- zipdata[order(zipdata$centile),]\nsensordata <- sensordata[order(sensordata$PM10),]\n\nfunction(input, output, session) {\n\n  ## Interactive Map ###########################################\n\n  # Create the map\n  output$map <- renderLeaflet({\n    leaflet() %>%\n      addTiles(\n        urlTemplate = \"//{s}.tiles.mapbox.com/v3/jcheng.map-5ebohr46/{z}/{x}/{y}.png\",\n        attribution = 'Maps by <a href=\"http://www.mapbox.com/\">Mapbox</a>'\n      ) %>%\n      setView(lng = 10.0, lat = 51.0, zoom = 6)\n  })\n\n  # A reactive expression that returns the set of zips that are\n  # in bounds right now\n  # zipsInBounds <- reactive({\n  #   if (is.null(input$map_bounds))\n  #     return(zipdata[FALSE,])\n  #   bounds <- input$map_bounds\n  #   latRng <- range(bounds$north, bounds$south)\n  #   lngRng <- range(bounds$east, bounds$west)\n  #\n  #   subset(zipdata,\n  #          latitude >= latRng[1] & latitude <= latRng[2] &\n  #            longitude >= lngRng[1] & longitude <= lngRng[2])\n  # })\n  zipsInBounds <- reactive({\n    if (is.null(input$map_bounds))\n      return(sensordata[FALSE,])\n    bounds <- input$map_bounds\n    latRng <- range(bounds$north, bounds$south)\n    lngRng <- range(bounds$east, bounds$west)\n\n    subset(sensordata,\n           latitude >= latRng[1] & latitude <= latRng[2] &\n             longitude >= lngRng[1] & longitude <= lngRng[2])\n  })\n\n\n  # Precalculate the breaks we'll need for the two histograms\n  #centileBreaks <- hist(plot = FALSE, allzips$centile, breaks = 20)$breaks\n  centileBreaks <- hist(plot = FALSE, sensordata$PM10, breaks = 20)$breaks\n\n  # output$histCentile <- renderPlot({\n  #   # If no zipcodes are in view, don't plot\n  #   if (nrow(zipsInBounds()) == 0)\n  #     return(NULL)\n  #\n  #   hist(zipsInBounds()$centile,\n  #        breaks = centileBreaks,\n  #        main = \"SuperZIP score (visible zips)\",\n  #        xlab = \"Percentile\",\n  #        xlim = range(allzips$centile),\n  #        col = '#00DD00',\n  #        border = 'white')\n  # })\n  output$histCentile <- renderPlot({\n    # If no zipcodes are in view, don't plot\n    if (nrow(zipsInBounds()) == 0)\n      return(NULL)\n\n    hist(zipsInBounds()$PM10,\n         breaks = centileBreaks,\n         main = \"SuperZIP score (visible zips)\",\n         xlab = \"Percentile\",\n         xlim = range(allsensors$PM10),\n         col = '#00DD00',\n         border = 'white')\n  })\n\n  # output$scatterCollegeIncome <- renderPlot({\n  #   # If no zipcodes are in view, don't plot\n  #   if (nrow(zipsInBounds()) == 0)\n  #     return(NULL)\n  #\n  #   print(xyplot(income ~ college, data = zipsInBounds(), xlim = range(allzips$college), ylim = range(allzips$income)))\n  # })\n  output$scatterCollegeIncome <- renderPlot({\n    # If no zipcodes are in view, don't plot\n    if (nrow(zipsInBounds()) == 0)\n      return(NULL)\n    x = range(allzips$college) / 10\n    print(xyplot(temp ~ PM10, data = zipsInBounds(), xlim = range(x), ylim = range(sensordata$temp)))\n  })\n\n\n  # This observer is responsible for maintaining the circles and legend,\n  # according to the variables the user has chosen to map to color and size.\n  observe({\n    colorBy <- input$color\n    #sizeBy <- input$size\n    #colorBy <- \"centile\"\n    sizeBy <- \"adultpop\"\n    zoom <- input$map_zoom\n\n    if (colorBy == \"superzip\") {\n      # Color and palette are treated specially in the \"superzip\" case, because\n      # the values are categorical instead of continuous.\n      colorData <- ifelse(sensordata$PM10 >= (100 - input$threshold), \"yes\", \"no\")\n      pal <- colorFactor(\"viridis\", colorData)\n    } else {\n      colorData <- sensordata[[colorBy]]\n      pal <- colorBin(\"viridis\", colorData, 7, pretty = FALSE)\n    }\n\n    if (sizeBy == \"superzip\") {\n      # Radius is treated specially in the \"superzip\" case.\n      radius <- ifelse(sensordata$PM10 >= (100 - input$threshold), 30000, 3000)\n    } else {\n      radius <- (sensordata[[\"PM10\"]] / sensordata[[\"PM10\"]] * 10000 ) / zoom\n      #print (radius)\n      #radius <- zipdata[[sizeBy]] / max(zipdata[[sizeBy]]) * 30000\n      #radius <- zipdata[[sizeBy]] / zipdata[[sizeBy]] * 2000\n    }\n\n    # leafletProxy(\"map\", data = zipdata) %>%\n    #   clearShapes() %>%\n    #   addCircles(~longitude, ~latitude, radius=radius, layerId=~zipcode,\n    #              stroke=FALSE, fillOpacity=0.4, fillColor=pal(colorData)) %>%\n    #   addLegend(\"bottomleft\", pal=pal, values=colorData, title=colorBy,\n    #             layerId=\"colorLegend\")\n    leafletProxy(\"map\", data = sensordata) %>%\n      clearShapes() %>%\n      addCircles(~longitude, ~latitude, radius=radius, layerId=~sensor_id,\n                 stroke=FALSE, fillOpacity=0.4, fillColor=pal(colorData)) %>%\n      addLegend(\"bottomleft\", pal=pal, values=colorData, title=colorBy,\n                layerId=\"colorLegend\")\n  })\n\n  # Show a popup at the given location\n  showZipcodePopup <- function(zipcode, lat, lng) {\n    \n    selectedSensor <- allsensors[allsensors$sensor_id == zipcode,]\n    content <- as.character(tagList(\n      tags$h4(\"SensorID:\", as.integer(selectedSensor$sensor_id)),\n      tags$strong(HTML(sprintf(\"%s, %s\",\n                               selectedSensor$country, selectedSensor$city\n      ))), tags$br(),\n      sprintf(\"Rain: %s L\", as.integer(selectedSensor$rain_3h)), tags$br(),\n      sprintf(\"Wind Speed: %s Degree: %s\", round(selectedSensor$wind_speed, digits = 2), round(selectedSensor$wind_deg, digits = 2)), tags$br(),\n      sprintf(\"Floating Average 24h: %s\", as.integer(selectedSensor$PM10_average)), tags$br(),\n      sprintf(\"PM10 Forecast: %s\", as.integer(selectedSensor$PM10))\n    ))\n    leafletProxy(\"map\") %>% addPopups(lng, lat, content, layerId = zipcode)\n  }\n\n  # When map is clicked, show a popup with city info\n  observe({\n    leafletProxy(\"map\") %>% clearPopups()\n    event <- input$map_shape_click\n    if (is.null(event))\n      return()\n\n    isolate({\n      showZipcodePopup(event$id, event$lat, event$lng)\n      print(event$id)\n    })\n  })\n\n\n  ## Data Explorer ###########################################\n\n  # observe({\n  #   cities <- if (is.null(input$states)) character(0) else {\n  #     filter(cleantable, State %in% input$states) %>%\n  #       `$`('City') %>%\n  #       unique() %>%\n  #       sort()\n  #   }\n  #   stillSelected <- isolate(input$cities[input$cities %in% cities])\n  #   updateSelectInput(session, \"cities\", choices = cities,\n  #                     selected = stillSelected)\n  # })\n\n  observe({\n    cities <- if (is.null(input$country)) character(0) else {\n      filter(cleansensors, Country %in% input$country) %>%\n        `$`('City') %>%\n        unique() %>%\n        sort()\n    }\n    stillSelected <- isolate(input$cities[input$cities %in% cities])\n    updateSelectInput(session, \"cities\", choices = cities,\n                      selected = stillSelected)\n  })\n  \n  observe({\n    zipcodes <- if (is.null(input$states)) character(0) else {\n      cleantable %>%\n        filter(State %in% input$states,\n               is.null(input$cities) | City %in% input$cities) %>%\n        `$`('Zipcode') %>%\n        unique() %>%\n        sort()\n    }\n    stillSelected <- isolate(input$zipcodes[input$zipcodes %in% zipcodes])\n    updateSelectInput(session, \"zipcodes\", choices = zipcodes,\n                      selected = stillSelected)\n  })\n\n  observe({\n    if (is.null(input$goto))\n      return()\n    isolate({\n      map <- leafletProxy(\"map\")\n      map %>% clearPopups()\n      dist <- 0.5\n      zip <- input$goto$zip\n      lat <- input$goto$lat\n      lng <- input$goto$lng\n      showZipcodePopup(zip, lat, lng)\n      map %>% fitBounds(lng - dist, lat - dist, lng + dist, lat + dist)\n    })\n  })\n\n  output$ziptable <- DT::renderDataTable({\n\n    df <- cleansensors %>%\n      # filter(\n      #   Score >= input$minScore,\n      #   Score <= input$maxScore,\n      #   is.null(input$states) | State %in% input$states,\n      #   is.null(input$cities) | City %in% input$cities,\n      #   is.null(input$zipcodes) | Zipcode %in% input$zipcodes\n      # ) %>%\n      filter(\n        PM10_Forecast >= input$minScore,\n        PM10_Forecast <= input$maxScore,\n        is.null(input$country) | Country %in% input$country,\n        is.null(input$cities) | City %in% input$cities\n        #is.null(input$zipcodes) | Zipcode %in% input$zipcodes\n      ) %>%\n      mutate(Action = paste('<a class=\"go-map\" href=\"\" data-lat=\"', Lat, '\" data-long=\"', Long, '\" data-zip=\"', SensorID, '\"><i class=\"fa fa-crosshairs\"></i></a>', sep=\"\"))\n    action <- DT::dataTableAjax(session, df)\n\n    DT::datatable(df, options = list(ajax = list(url = action)), escape = FALSE)\n  })\n}\n",
    "created" : 1505992328764.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2198726353",
    "id" : "7F9879EE",
    "lastKnownWriteTime" : 1505917257,
    "last_content_update" : 1505917257,
    "path" : "C:/Users/lmueller2/Dropbox/map_r/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}